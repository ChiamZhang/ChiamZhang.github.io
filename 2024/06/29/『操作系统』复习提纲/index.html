

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Mine.jpg">
  <link rel="icon" href="/img/Mine.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Chiam">
  <meta name="keywords" content="Algorithms，Cybersecurity">
  
    <meta name="description" content="『操作系统』复习提纲图也没有，我复习用的。将就看吧，不排版了 操作系统复习第一章 概述1、操作系统的概念、基本类型、基本特征、基本功能、管态&#x2F;目态； 2、操作系统的目标、作用、结构设计方法；第二章 进程管理1、多道程序设计技术（多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行）；2、进程的概念、特征、基本状态及与程序的区别和联系；(1).为">
<meta property="og:type" content="article">
<meta property="og:title" content="『操作系统』复习提纲">
<meta property="og:url" content="https://chiamzhang.github.io/2024/06/29/%E3%80%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/index.html">
<meta property="og:site_name" content="Blogs of 风骨散人Chiam">
<meta property="og:description" content="『操作系统』复习提纲图也没有，我复习用的。将就看吧，不排版了 操作系统复习第一章 概述1、操作系统的概念、基本类型、基本特征、基本功能、管态&#x2F;目态； 2、操作系统的目标、作用、结构设计方法；第二章 进程管理1、多道程序设计技术（多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行）；2、进程的概念、特征、基本状态及与程序的区别和联系；(1).为">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-06-29T13:16:53.831Z">
<meta property="article:modified_time" content="2023-12-05T16:18:05.397Z">
<meta property="article:author" content="Chiam">
<meta property="article:tag" content="Algorithms，Cybersecurity">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>『操作系统』复习提纲 - Blogs of 风骨散人Chiam</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"chiamzhang.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>风骨散人Chiam Blogs</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="『操作系统』复习提纲"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-29 21:16" pubdate>
          June 29, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          147 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">『操作系统』复习提纲</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="『操作系统』复习提纲"><a href="#『操作系统』复习提纲" class="headerlink" title="『操作系统』复习提纲"></a>『操作系统』复习提纲</h1><p><strong>图也没有，我复习用的。将就看吧，不排版了</strong></p>
<p>操作系统复习<br>第一章 概述<br>1、操作系统的概念、基本类型、基本特征、基本功能、管态&#x2F;目态；</p>
<p>2、操作系统的目标、作用、结构设计方法；<br>第二章 进程管理<br>1、多道程序设计技术（多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行）；<br>2、进程的概念、特征、基本状态及与程序的区别和联系；<br>(1).为什么要引入进程:并发运行的程序相互制约<br>(2).进程的概念:可并发执行的程序在一个数据集合上的一次执行过程。进程是进程实体的一次动态运行过程，是系统进行资源分配和调度的一个基本单位。<br>(3).特征:<br>(1)动态性——进程是程序在处理机上的一次执行过程。具有生命期。<br>(2)并发性——多个进程实体同存于内存中，在一段时间内同时运行。以提高资源利用率。<br>(3) 独立性— 进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位，而程序则不是。<br>(4) 异步性–进程按各自独立的、不可预知的速度向前推进。<br>(5) 结构性— 进程控制块(PCB)+程序段+相关的数据段&#x3D;进程实体。</p>
<p>(4)进程和程序区别:</p>
<p>(4) .进程的三个基本状态<br>(1).进程的基本状态-三态模型<br>•执行态（running）：进程占有处理器正在运行。<br>•就绪态（ready）：进程具备运行条件，等待系统分配处理器以便运行。<br>•阻塞态（block）：又称为等待（wait）态或睡眠（sleep）态，进程不具备运行条件，正在等待某个事件的完成。</p>
<p>•运行态 → 阻塞态：等待使用资源或某事件发生；<br>•阻塞态 → 就绪态：资源得到满足或事件发生；<br>•运行态 → 就绪态：运行时间片到；<br>出现有更高优先权进程。<br>•就绪态 → 运行态：CPU 空闲时选择一个就绪进程。<br>(2)五态模型<br>新建态—对应进程刚被创建的状态。<br>终止态—进程的终止状态。</p>
<p>(3).七态模型<br>(1)为什么要有“挂起”状态?<br>由于进程的不断创建，系统资源已不能满足进程运行的要求，就必须把某些进程挂起（suspend），对换到磁盘镜像区中，暂时不参与进程调度，起到平滑系统负载的目的。<br>•挂起就绪态（ready suspend）：表明进程具备运行条件但目前在辅助存储器中，当它被对换到主存才能被调度执行。<br>•挂起等待态（blocked suspend）：表明进程正在等待某一个事件且在辅助存储器中。</p>
<p>• 该进程不能立即被执行。<br>• 挂起进程可能会等待事件，但所等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。<br>• 进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。<br>• 结束进程挂起状态的命令只能通过操作系统或父进程发出。</p>
<p>3、PCB 的概念、前趋图、进程图(进程图上题三个模型)；<br>(1).PCB 的概念:进程控制块,存放进程的管理和控制信息的数据结构.( 进程控制块是进程存在的唯一标志。<br>)<br>它是管理和控制的进程最重要的数据结构，在创建时，建立 PCB，并伴随进程运行的全过程，直到进程撤消而撤消。PCB 就象我们的户口。<br>系统的所有 PCB 组织成链表或队列，常驻内存的 PCB 区。</p>
<p>了解<strong>进程控制块中的信息</strong></p>
<ol>
<li><p>进程标识符信息<br> 每个进程都必须有一个唯一的标识符<br>内部标识符：便于系统使用<br>外部标识符：便于用户使用</p>
</li>
<li><p>处理机状态信息<br>处理机状态信息主要由处理机的各种寄存器中的内容组成。处理机运行时的信息存放在寄存器中，当被中断时这些信息要存放在 PCB 中。</p>
</li>
<li><p>进程调度信息<br>进程优先级<br>进程调度所需的其他信息<br>事件<br>进程状态</p>
</li>
<li><p>进程控制信息<br>程序和数据的地址<br>进程同步和通信机制<br>资源清单<br>链接指针</p>
</li>
</ol>
<p>前趋图是一个有向无环图 (DAG-Directed Acyclic Graph)，用于描述进程之间执行的前后关系。</p>
<p>结 点 ： 描述一个程序段或进程，<br>或一条语句。<br>有 向 边： 结点之间的前趋关系“”<br>Pi  Pj ：Pi 必须在 Pj 开始之前完成， Pi 是 Pj 的直接前趋，Pj 是 Pi 的直接后继<br>初始结点: 没有前趋的结点<br>终止结点: 没有后继的结点<br>注意：前趋图中绝对不能出现循环！！！</p>
<p>4、原语的概念及进程控制原语的种类；<br>**进程控制是操作系统的内核通过原语来实现的。<br>进程的创建与终止<br>进程的阻塞与唤醒<br>进程的挂起与激活</p>
<p>**控制原语的种类:关锁：Lock(W)开锁：unLock(W) Wait 操作 wait(S) Signal 操作 signal(S)</p>
<ol>
<li>直接通信方式<br>通信原语：<br>Send(Receiver, message);发送一个消息给接收进程<br>Receive(Sender, message);接收 Sender 发来的消息</li>
</ol>
<p>(1).原语(primitive)：由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割－－要么全都完成，要么全都不做。许多系统调用就是原语。<br>特征:“不可中断性”!</p>
<p>5、进程的同步与互斥的概念、临界资源与临界区的概念；<br>同步是进程间共同完成一项任务时直接发生相互作用的关系！ 同步进程间具有合作关系,在执行时间上必须按一定的顺序协调进行<br>互斥是并发执行的多个进程由于竞争同一资源而产生的相互排斥的关系！ 互斥进程彼此在逻辑上是完全无关的它们的运行不具有时间次序的特征<br>**临界资源：一次仅允许一个进程使用的共享资源！如：打印机、磁带机、共享表格、共享变量等。<br>**临界区：每个进程中访问临界资源的那段程序！<br>进程必须互斥进入相关临界区！</p>
<p>6、信号量及其应用；<br>【典型题举例】系统中有三个进程 GET、PRO 和 PUT，共用两个缓冲区 BUF1 和 BUF2。<br>假设 BUF1 中最多可放 11 个信息，现已放入了两个信息；BUF2 最多可放 5 个信息，目前为空。<br>GET 进程负责不断地将输入信息送入 BUF1 中，PRO 进程负责从 BUF1 中取出信息进行处理，并将处理结果送到 BUF2 中，PUT 进程负责从 BUF2 中读取结果并输出。<br>试写出正确实现 GET、PRO、PUT 的同步与互斥的算法（要求：（1）用类 C 语言描述，条理清楚，注释恰当；（2）信号量原语统一使用 wait 和 signal）。</p>
<p>图 1 进程合作</p>
<p>Semaphore e1&#x3D;9,p1&#x3D;2,e2&#x3D;5,p2&#x3D;0;<br>Main(){<br>Cobegin<br>Get();<br>Pro();<br>Put();<br>coend<br>}<br>Get<br>While(1){<br>Wait(e1);<br>Put in buf1;<br>Signal(p1);}<br>Pro<br>Wait(p1);<br>Get from buf1;<br>Signal(e1);<br>Wait(e1);<br>Put in buf2<br>Signal(p2);<br>Put<br>Wait(p2)<br>Get from buf2<br>Signal(e2)</p>
<p>生产围棋的工人不小心把相等数量的黑子和白子混装在一个箱子里，现要用自动分拣系统把黑子和白子分开，该系统由两个并发执行的进程组成，功能如下：<br>（1）进程 A 专门拣黑子，进程 B 专门拣白子；<br>（2）每个进程每次只拣一个子，当一个进程在拣子时不允许另一个进程去拣子；<br>分析：<br>　　第一步：确定进程间的关系。由功能（2）可知进程之间是互斥的关系。<br>　　第二步：确定信号量及其值。由于进程 A 和进程 B 要互斥进入箱子去拣棋子，箱子是两个进程的公有资源，所以设置一个信号量 s，其值取决于公有资源的数目，由于箱子只有一个，s 的初值就设为 1。</p>
<p>semaphore s&#x3D;1;<br>　　 main(){<br>　 cobegin{<br>　　　　 process A：while(1){<br>　　　　 Wait(s);<br>　　　　　 拣黑子；<br>　　　　　 Signal(s);<br>　　　　　 }<br>　　　　 process B：while(1){<br>　　　　 Wait(s);<br>　　　　　 拣白子；<br>Signal(s);<br>}<br>　　　}coend<br>}<br>　 semaphore s&#x3D;1;<br>　　 main(){<br>　 cobegin{<br>　　　　 process A：while(1){<br>　　　　 Wait(s);<br>　　　　　 拣黑子；<br>　　　　　 Signal(s);<br>　　　　　 }<br>　　　　 process B：while(1){<br>　　　　 Wait(s);<br>　　　　　 拣白子；<br>Signal(s);<br>}<br>　　　}coend<br>}<br>某车站售票厅共有 20 个售票窗口，任何时刻最多可容纳 20 名购票者进入，当售票厅中少于 20 名购票者时，厅外的购票者可立即进入，否则需要在外面等待。每个购票者可看成一个进程。<br>第一步：确定进程间的关系：售票厅是各进程共享的公有资源，当售票厅中多于 20 名购票者时，厅外的购票者需要在外面等待。所以进程间是互斥的关系。<br>第二步：确定信号量及其值：只有一个公有资源-售票厅，所以设置一个信号量 s。售票厅最多容纳 20 个购票者，即可用资源实体数为 20，s 的初值就设为 20。<br>　　 semaphore s&#x3D;20;<br>　　 main(){<br>cobegin{<br>　　　 process Pi(i&#x3D;1,2,……)(){<br>　　　　 Wait(s);<br>　　　　　进入售票厅；<br>　　　　　购票；<br>　　　　　退出；<br>　　　　　 Signal(s);<br>　　　　}<br>　　　}coend<br>}</p>
<p>例 5：图书馆问题<br>图书馆有 100 个座位，有一张登记表，要求：<br>阅读者进入时登记，取得座位号；<br>出来时，注销(注销也要使用登记表)；<br>登记表同时只能由一个人使用；<br>用信号量描述一个读者的使用过程。<br>信号量 SN：表示可用座位数，初值为 100；<br>信号量 mutex：表示登记表是否正在使用，初值为 1；<br>Reader(int i)<br>{ Wait(SN)；<br>Wait(mutex)；<br>登记；<br>Signal(mutex)；<br>阅读;<br>Wait(mutex);<br>注销；<br>Signal(mutex);<br>Signal(SN);<br>}</p>
<p>用信号量实现简单同步<br>同步（私有）信号量：<br>用于实现进程间的同步，初值为 0 或为某个正整数 n，仅允许拥有它的进程对其实施 Wait 操作。<br>Signal 操作由其合作进程来实施！</p>
<p>设 2 个信号量：<br>empty—空缓冲区数（初值为 1）<br>full—满缓冲区数（初值为 0）</p>
<p>供者进程<br>while(1)<br>{ Wait（empty）;<br>将信息送<br>入缓冲区；<br>Signal（full）;<br>}</p>
<p>用者进程<br>while(1)<br>{ Wait（full）;<br>从缓冲区<br>取出信息；<br>Signal（empty）;<br>}</p>
<p>例：有 3 个进程 PA，PB 和 PC 合作解决文件打印问题：<br>PA 将文件记录从磁盘读入主存的缓冲区 1，每执行一次读一个记录;<br>PB 将缓冲区 1 的内容复制到缓冲区 2，每执行一次复制一个记录；<br>PC 将缓冲区 2 的内容打印出来，每执行一次打印一个记录。缓冲区的大小等于一个记录大小。<br>要求：请用信号量机制来保证文件的正确打印。</p>
<p>设置 4 个信号量：empty1, empty2,full1,full2.<br>empty1 及 empty2 分别表示缓冲区 1 及缓冲区 2 是否为空，初值为 1。<br>full1，full2 分别表示缓冲区 1 及缓冲区 2 是否有记录可供处理，其初值为 0。</p>
<p>PA()<br>{While (1)<br>{ 从磁盘读一个记录；<br>Wait(empty1);<br>将记录存入缓冲区 1；<br>Signal(full1); }}</p>
<p>PB()<br>{While (1)<br>{ Wait(full1);<br>Wait(empty2);<br>将缓冲区 1 中的记录<br>复制到缓冲区 2；<br>Signal(empty1);<br>Signal(full2); }}</p>
<p>PC()<br>{While (1)<br>{Wait(full2);<br>从缓冲区 2 取一个记录；<br>Signal(empty2);<br>打印记录;}}</p>
<p>semaphore empty1&#x3D;1; empty2&#x3D;1;full1&#x3D;0;full2&#x3D;0;<br>main()<br>{ cobegin{<br>PA();<br>PB();<br>PC();<br>}coend }</p>
<p>生产围棋的工人不小心把相等数量的黑子和白子混装在一个箱子里，现要用自动分拣系统把黑子和白子分开，该系统由两个并发执行的进程组成，功能如下：<br>（3） 当一个进程拣了一个棋子（黑子或白子）以后，必让另一个进程拣一个棋子（白子或黑子）。<br>第一步：确定进程间的关系。由条件 1、2、3 可知，进程间的关系为同步关系。<br>第二步：确定信号量及其值。进程 A 和 B 共享箱子这个公有资源，但规定两个进程必须轮流去取不同色的棋子，因而相互间要互通消息。对于进程 A 可设置一个私有信号量 s1，该私有信号量用于判断进程 A 是否能去拣黑子，初值为 1。对于进程 B 同样设置一个私有信号量 s2，该私有信号量用于判断进程 B 是否能去拣白子，初值为 0。<br>semaphore s1&#x3D;1,s2&#x3D;0;<br>main()<br>{ cobegin<br>{ PA();<br>PB();<br>}coend }<br>PA()<br>{While (1)<br>{Wait(s1);<br>拣黑子；<br>Signal(s2);<br>}<br>}<br>PB()<br>{While (1)<br>{ Wait(s2);<br>拣白子；<br>Signal(s1);<br>}<br>}</p>
<p>设信号量 :<br>S1：是否允许司机启动汽车，初值为 0<br>S2：是否允许售票员开门，初值为 0<br>Driver()<br>while (1)<br>{<br>Wait(S1);<br>启动汽车;<br>正常行车；<br>到站停车；<br>Signal(S2); }</p>
<p>Busman()<br>while (1){<br>关车门;<br>Signal(S1)；<br>售票；<br>Wait(S2)；<br>开车门；<br>上下乘客；<br>}</p>
<p>semaphore s1&#x3D;0, s2&#x3D;0;<br>main{<br>cobegin<br>{ Driver();<br>Busman();<br>}coend<br>}<br>生产者－消费者问题<br>若干进程通过有限的共享缓冲区交换数据。其中，”生产者”进程不断写入，而”消费者”进程不断读出；共享缓冲区共有 N 个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p>
<p>一个生产者，一个消费者，公用一个缓冲区 ；<br>一个生产者，一个消费者，公用 n 个环形缓冲区 ；<br>一组生产者，一组消费者，公用 n 个环形缓冲区</p>
<p>生产者进程<br>while(TRUE)<br>{<br>生产一个产品;<br>Wait(empty);<br>产品送往 Buffer;<br>Signal(full);<br>}</p>
<p>消费者进程<br>while(TRUE)<br>{<br>Wait(full);<br>从 Buffer 取出一个产品;<br>Signal(empty);<br>消费该产品;<br>}</p>
<p>一个生产者，一个消费者，公用 n 个环形缓冲区</p>
<p>Empty：表示缓冲区是否为空，初值为 n。<br>Full ：表示缓冲区是否为满，初值为 0。<br>设缓冲区的编号为 1 ～ n1，定义两个指针 in 和 out，分别是生产者进程和消费者进程使用的指针，指向下一个可用的缓冲区。<br>生产者进程</p>
<p>while(TRUE)<br>{<br>生产一个产品;<br>Wait(empty);<br>产品送往 buffer（in）；<br>in&#x3D;(in+1)mod n；<br>Signal(full);<br>}<br>消费者进程</p>
<p>while(TRUE)<br>{<br>Wait(full);<br>从 buffer(out)中取出产品；<br>out&#x3D;(out+1)mod n；<br>Signal(empty);<br>消费该产品;<br>}</p>
<p>Empty：表示缓冲区是否为空，初值为 n。<br>Full ：表示缓冲区是否为满，初值为 0。<br>Mutex1：生产者之间的互斥信号量，初值为 1。<br>Mutex2：消费者之间的互斥信号量，初值为 1。</p>
<p>设缓冲区的编号为 1 ～ n1，定义两个指针 in 和 out，分别是生产者进程和消费者进程使用的指针，指向下一个可用的缓冲区。</p>
<p>生产者进程<br>while(TRUE)<br>{<br>Wait(empty);<br>Wait(mutex1)；<br>产品送往 buffer(in)；<br>in&#x3D;(in+1)mod n；<br>Signal(mutex1);<br>Signal(full);<br>}<br>消费者进程<br>while(TRUE)<br>{<br>Wait(full);<br>Wait(mutex2)；<br>从 buffer(out)中取出产品；<br>out&#x3D;(out+1)mod n；<br>Signal(mutex2)；<br>Signal(empty);<br>消费该产品;<br>}<br>桌子上有一个水果盘，每一次可以往里面放入一个水果。爸爸专向盘子中放苹果，儿子专等吃盘子中的苹果。把爸爸、儿子看作二个进程，试用 Wait&#x2F;Signal 操作使这二个进程能正确地并发执行。<br>semaphore S_PlateNum; &#x2F;&#x2F; 盘子容量，初值为 1<br>semaphore S_AppleNum; &#x2F;&#x2F; 苹果数量，初值为 0<br>父亲进程<br>while(TRUE)<br>{<br>拿苹果；<br>Wait(S_PlateNum );<br>往盘子中放入一个苹果；<br>Signal(S_AppleNum);<br>}<br>儿子进程<br>while(TRUE)<br>{<br>Wait(S_AppleNum);<br>从盘中取出苹果；<br>Signal(S_PlateNum);<br>吃苹果;<br>}<br>桌上有一空盘，允许存放一只水果，爸爸可向盘中放苹果，也可向盘中放桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定当盘空时一次只能放一只水果供吃者取用。<br>请用 Wait&#x2F;Signal 原语实现爸爸、儿子、女儿三个并发进程的同步。<br>Semaphore S&#x3D;1; &#x2F;&#x2F;S 表示盘子是否为空；<br>Semaphore S1&#x3D;0; &#x2F;&#x2F;S1 表示盘中是否有苹果；<br>Semaphore S2&#x3D;0; &#x2F;&#x2F;S2 表示盘中是否有桔子；<br>while(TRUE)<br>{<br>Wait(S);<br>将水果放入盘中;<br>if (放入的是桔子)<br>Signal(S2);<br>Else<br>Signal(S1);</p>
<p>}<br>while(TRUE)<br>{<br>Wait(S2);<br>从盘中取出桔子；<br>Signal(S);<br>吃桔子;<br>}<br>while(TRUE)<br>{<br>Wait(S1);<br>从盘中取出苹果；<br>Signal(S);<br>吃苹果;<br>}<br>父亲-母亲-儿子-女儿<br>一个苹果或桔子<br>Semaphore：s&#x3D;1(空盘数);<br>s1&#x3D;0(苹果数);s2&#x3D;0(桔子数);<br>爸爸：while(true) { wait(s); 放苹果; signal(s1); }<br>妈妈：while(true) { wait(s); 放桔子; signal(s2); }<br>儿子：while(true) { wait(s2); 取桔子; signal(s); }<br>女儿：while(true) { wait(s1); 取苹果; signal(s); }</p>
<p>父亲-母亲-儿子-女儿<br>两个苹果或桔子<br>Semaphore：s&#x3D;2(可用位置); s1&#x3D;0(苹果数);<br>s2&#x3D;0(桔子数);mutex&#x3D;1;<br>爸爸：wait(s); wait(mutex);放苹果; signal(mutex); signal(s1);<br>妈妈：wait(s); wait(mutex); 放桔子; signal(mutex); signal(s2);<br>儿子：wait(s2); wait(mutex); 取桔子; signal(mutex); signal(s);<br>女儿：wait(s1); wait(mutex); 取苹果; signal(mutex); signal(s);<br>练习题：某寺庙有小和尚、老和尚若干。<br>有一个水缸，由小和尚打水入缸供老和尚饮用。<br>水缸可容纳 10 桶水。<br>水取自同一井中。每次只能容纳一个桶取水。<br>水桶总数为 3 个。每次入、取水仅为一桶，且不可同时进行。<br>给出有关取水、入水的算法描述。<br>semaphore empty&#x3D;10;&#x2F;&#x2F; 表示缸中目前还能装多少桶水，<br>初始时能装 10 桶水<br>semaphore full&#x3D;0;&#x2F;&#x2F; 表示缸中有多少桶水，<br>初始时缸中没有水<br>semaphore buckets&#x3D;3;&#x2F;&#x2F; 表示有多少只空桶可用，<br>初值为 3<br>semaphore mutex_well&#x3D;1;&#x2F;&#x2F; 用于实现对井的互斥操作<br>semaphore mutex_bigjar&#x3D;1; &#x2F;&#x2F; 用于实现对缸的互斥操作<br>young_monk(){<br>while(1){<br>Wait(empty);<br>Wait(buckets);<br>go to the well;<br>Wait(mutex_well);<br>get water;<br>Signal(mutex_well);<br>go to the temple;<br>Wait(mutex_bigjar);<br>pour water into the big jar;<br>Signal(mutex_bigjar);<br>Signal(buckets);<br>Signal(full);<br>}<br>}<br>old_monk(){<br>while(1){<br>Wait(full);<br>Wait(buckets);<br>Wait(mutex_bigjar);<br>get water;<br>Signal(mutex_bigjar);<br>Signal(empty);<br>drink water;<br>Signal(buckets);<br>}<br>}</p>
<p><strong>哲学家进餐问题</strong><br>放在桌子上的筷子是临界资源，在一段时间内只允许一个哲学家使用。为实现对筷子的互斥使用，用一个信号量表示一只筷子，五个信号量构成信号量数组。<br>semaphore chopstick[5];<br>所有信号量均被初始化为 1。<br>semaphore chopstick[5] &#x3D;{1, 1, 1, 1, 1};<br>Process i()<br>{ while(true){<br>think;<br>Swait(chopstick[ ( i +1) % 5] , chopstick[ i ] );<br>eat;<br>Ssignal(chopstick[ ( i +1) % 5] , chopstick[ i ] );<br> }<br>}</p>
<p>7、线程的概念及种类、引入线程的目的；</p>
<p>目的:<br>减少程序在并发执行时所付出的时空开销，使操作系统具有更好的并发性。</p>
<p>线程：进程中一个相对独立的执行流。线程是 CPU 执行单位,作为 CPU 调度单位。</p>
<p>用户级线程 User-level threads<br>内核支持线程 Kernel Supported threads<br>组合方式</p>
<p>补充:</p>
<p>8.程序顺序执行时的特征<br>(1) 顺序性<br>处理机的操作严格按照程序所规定的顺序执行。<br>(2) 封闭性<br>程序一旦开始执行，其计算结果不受外界因素的影响。<br>(3) 可再现性<br>程序执行的结果与它的执行速度无关(即与时间无关)，而只与初始条件有关。<br>例如:<br>I1、C1、P1 的执行必须严格按照 I1，C1，P1 的顺序，而 P1 与 I2，C1 与 I2，I3 与 P1 是可以同时执行的。</p>
<p>9 操作系统内核主要包含两个功能：<br>（1）支撑功能</p>
<p>（2）资源管理功能</p>
<p>内核：计算机硬件的第一层扩充软件<br>第三章 处理机调度与死锁<br>1、 调度的层次与作用；<br>处理机调度的层次<br>高级调度(长程调度)：作业调度 高级调度适用于<br>批处理系统 ：需要作业调度<br>分时系统 ：不需作业调度<br>实时系统 ：不需作业调度<br>中级调度(中程调度)：内存调度<br>目的：为了提高内存利用率和系统吞吐量。<br>低级调度(短程调度)：进程调度<br>在多道批处理、分时、实时 OS 中，都有 LLS。<br>调度的对象是进程（或内核级线程）<br>主要功能：根据某种算法，决定就绪队列中的哪个进程应获得处理机 ，并由分派程序将处理机分配给被选中的进程。</p>
<p>调度的职能<br>(1) 记录系统中所有进程的有关情况<br>(2) 确定分配处理机的原则<br>(3) 分配处理机给进程<br>(4) 从进程收回处理机<br>2、常用调度算法及计算；(看笔记:FCFS,SJF,高响应比优先调度算法,轮转调度算法(看课本))<br>【典型题举例】设有三个作业，它们的提交时间及运行时间如下表，若采用短作业优先调度策略，试给出作业串行运行时的调度次序，计算平均周转时间。<br>作业　提交时间　运行时间　<br>J1 　　　 0 　　　　 4<br>J2 　　　 2 　　　 8<br>J3 　　　 3 　　　　 5</p>
<p>P1 0 8<br>P2 1 4<br>P3 2 1<br>进程 已占有资源 最大需求数<br>A 　 B 　 C 　 D A 　 B 　 C 　 D<br>P1 0 　 0 　 1 　 2 0 　 0 　 1 　 2<br>P2 1 　 0 　 0 　 0 1 　 7 　 5 　 0<br>P3 1 　 3 　 5 　 4 2 　 3 　 5 　 6<br>P4 0 　 6 　 3 　 2 0 　 6 　 5 　 2<br>P5 0 　 0 　 1 　 4 0 　 6 　 5 　 6<br>P4 4 3</p>
<p>3、死锁的概念、产生的原因及必要条件；<br>死锁的概念:<br>指进程之间无休止地互相等待!<br>饥饿（Starvation）:指一个进程无休止地等待！<br>产生的原因<br>(1).竞争资源。<br>资源类型：<br>可剥夺和非剥夺性资源<br>永久性资源和临时性资源<br>(2).进程间推进顺序非法。<br>必要条件:</p>
<ol>
<li><p>互斥条件<br>指进程对所分配到的资源进行排他性使用;<br>即在一段时间内某资源只由一个进程占用;<br>如果此时还有其他进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。</p>
</li>
<li><p>请求和保持条件<br>指进程已经保持了至少一个资源，但又提出了新的资源请求;<br>而该资源又被其他进程占有;<br>此时请求进程阻塞，但又对自己已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件<br>指进程已获得的资源，在未使用完之前，不能被剥夺;<br>只能在使用完时由自己释放。 4.环路等待条件<br>指在发生死锁时，必然存在一个“进程—资源”的环形链;</p>
</li>
</ol>
<p>4、处理死锁的基本方法；<br>一、预防死锁——消除产生死锁的必要条件（静态）<br>二、避免死锁——分配资源时防止进入不安全状态（动态）<br>三、检测死锁——不预防死锁，随时检测死锁（动态）<br>四、解除死锁——出现死锁就解除（动态）</p>
<p>5、银行家算法及计算；(看笔记)</p>
<p>（1）如果 Requesti[j]&lt;&#x3D; Need[i,j],便转向步骤 2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。<br>（2）如果 Requesti[j]&lt;&#x3D; Available[j],便转向步骤 3；否则，表示尚无足够资源，Pi 需等待。<br>（3）系统试探着把资源分配给进程 Pi ，并修改下面数据结构中的数值：<br>Available[j]:&#x3D; Available[j]- Requesti[j];<br>Allocation[i,j]:&#x3D;Allocation[i,j]+Requesti[j];<br>Need[i,j]:&#x3D;Need[i,j]-Requesti[j];<br>（4）系统执行安全性算法，检查此次资源分配后系统是否处于安全状态以决定是否完成本次分配。</p>
<p>【典型题举例】<br> 某系统有 A、B、C、D 四类资源可供五个进程 P1.P2.P3.P4.P5 共享。系统对这四类资源的拥有量为：A 类 3 个、B 类 14 个、C 类 12 个、D 类 12 个。进程对资源的需求和分配情况如下,请问现在是否是安全状态，请说明原因及判断过程。<br> 化简下图的资源分配图，并说明有无进程处于死锁状态。</p>
<p>第四章 存储管理<br>1、存储管理的目的、功能；<br>功能:<br>内存分配与回收<br>内存共享与保护<br>内存扩充<br>地址变换<br>目的:<br>方便用户和提高主存利用率<br>2、重定位的概念及方法；<br>概念:把程序中的逻辑地址变成内存中的物理地址的过程叫做重定位。<br>方法:<br>绝对装入方式<br>在编译时，如果知道程序驻留在内存的什么位置，那么编译程序将产生绝对地址的目标代码。<br>程序中的逻辑地址与实际内存地址完全相同，无需对程序和数据的地址进行变换。<br>优点：装入过程简单。<br>缺点：过于依赖硬件结构，不便多道程序系统。<br>静态重定位装入方式<br>在多道程序环境下，目标模块的起始地址通常从 0 开始，程序中的其它地址都是相对于起始地址计算的；<br>因此应采用可重定位装入方式，根据内存的实际情况，将装入模块装入到内存的适当位置。<br>动态重定位装入方式<br>程序装入内存后，并不立即实施地址变换，而是把这种地址转换推迟到程序真正运行时才进行；<br>装入内存后仍是相对地址；<br>应设置一个重定位寄存器。</p>
<p>3、内碎片、外碎片；</p>
<p>4、常用分区分配算法及对应的空闲区排列方式；<br>(1)单一连续分配<br>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。<br>最简单，适用于单用户、单任务的 OS。<br>优点：易于管理。<br>缺点：<br>对要求内存空间少的程序，造成内存浪费；<br>程序全部装入，很少使用的程序部分也占用内存。<br>(2)固定分区分配<br>基本原理及技术<br>系统提前把内存分为一些大小相等或不等的分区(partition)，每个进程占用一个分区。操作系统占用其中一个分区。<br>适用于多道程序系统和分时系统<br>支持多个程序并发执行<br>划分分区的方法:</p>
<p>(3)动态(可变)分区分配<br>动态创建分区：<br>在装入程序时按其初始要求分配；<br>或在其执行过程中通过系统调用进行分配或改变分区大小。<br>优点：没有内碎片。<br>缺点：有外碎片；</p>
<p>(4)动态可重定位分区分配</p>
<p>常用的分配算法</p>
<p>(1) 首次适应算法 FF(First Fit)<br>(2) 循环首次适应算法 NF(Next Fit)<br>(3) 最佳适应算法 BF(Best Fit)<br>(4) 最坏适应算法 WF(Worst Fit)</p>
<p>5、基本分页（分段）的概念、页（段）表的作用、地址变换过程及物理地址计算；<br>基本分页存储管理方式 1.分页存储管理的基本方法<br>将程序的逻辑地址空间划分为固定大小的页;<br>物理内存划分为固定大小的块（页架）;<br>程序加载时，分配其所需的所有页，这些页不必连续。需要 CPU 的硬件支持。</p>
<p>页面和物理块</p>
<p>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片称为页，并为各页加以编号，从 0 开始。<br>同时把内存空间分成与页面相同大小的若干个存储块，称为块。<br>在为进程分配内存时，以块为单位将进程的若干个页分别装入到多个可以不相邻的物理块中。<br>进程的最后一页经常装不满而形成“页内碎片”。</p>
<p>假定地址长度 32 位:<br>每页的大小为 4KB , 即：011 位为位移量(页内地址)<br>则：12 31 位为页号，地址空间最多允许有 1M 页<br>设有一页式存储管理系统，向用户提供的逻辑地址空间最大为 16 页，每页 2048B，内存总共有 8 个存储块，试问逻辑地址至少应为多少位？内存空间有多大？<br>解：（1）页式存储管理系统的逻辑地址为：<br>其中页内地址表每页的大小即 2048B&#x3D;2*1024B&#x3D;2^11B，所以页内地址为 11 位。<br>其中页号表最多允许的页数即 16 页&#x3D;2^4 页，所以页号为 4 位。<br>故逻辑地址至少应为 15 位。<br>（2）物理地址为：<br> 其中块内地址表每块的大小与页大小相等，所以块内地址也为 11 位。<br>其中块号表内存空间最多允许的块数即 8 块&#x3D;2^3 块，所以块号为 3 位。<br>故内存空间至少应为 14 位，即 2^14 &#x3D;16KB</p>
<p>1.分段地址结构<br>由于整个作业的地址空间是分成多个段，因而是二维的，亦即，其逻辑地址由段号(段名)和段内地址所组成。</p>
<p>该地址结构允许一个作业最长有 64K 个段，每段的最大长度为 64KB。</p>
<p>对于下表所示的段表，请将逻辑地址(0，137)，<br>(1，4000)，(2，3600)，(5，230)转换成物理地址。</p>
<p>【典型题举例】<br>（1）某页式存储系统页表如下，设每页 1KB，请写出逻辑地址为 8300 时所对应的页号和页内地址，以及在内存中对应的物理地址。（请详细写出运算过程）<br>系统页表：<br>页号 0 1 2 3 4 5 6 7 8<br>块号 3 5 6 10 8 7 1 2 4</p>
<p>（2）已知如下段表：<br>段号 0 1 2 3 4<br>基址 219 2300 90 1327 1952<br>长度 600 14 100 580 96<br>在分段存储管理下系统运行时，下列逻辑地址（第一位表示段号，第二位表示段内位移）的物理地址是什么？<br>（a）：（1，10）<br>（b）：（4，112）<br>6、分页与分段的区别、各自的优缺点；</p>
<p>7、快表的作用、内存访问时间的计算；</p>
<p>第五章 虚拟存储器<br>1、虚拟存储器的基本概念、理论依据、基本特征及关键技术；<br>是指具有请求调入功能和置换功能， 能从逻辑上对内存容量加以扩充的一种存储器系统。<br>其容量接近于外存，其运行速度接近于内存速度，而每位的成本却又接近于外存。<br>**在虚存管理中，虚拟地址空间是指逻辑地址空间，<br>实地址空间是指物理地址空间；<br>前者的大小受 CPU 可寻址范围(机器地址长度)的限制，<br>而后者的大小受物理内存大小的限制。</p>
<p>**基本特征:<br>多次性：一个作业被分成多次调入内存运行<br>对换性：允许在作业的运行过程中进行换进、换出。<br>虚拟性：能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。<br>虚拟性以多次性和对换性为基础。</p>
<p>实现虚存技术的物质基础<br>二级存储结构——内存+外存<br>动态地址转换机构——将逻辑地址转换成物理地址<br>虚拟存储管理实现技术<br>请求分页虚拟存储管理<br>请求分段虚拟存储管理<br>请求段页式虚拟存储管理</p>
<p>2、熟知请求分页基本思想；<br>1）请求分页&#x3D;分页+请求<br>逻辑空间分页 物理空间分块<br>页与块同样大 页连续块离散<br>用页号查页表 硬件做重定位</p>
<p>（2）作业部分装入内存<br>（3）作业所占的内存块不连续<br>（4）硬件通过页表生成访问内存的地址<br>（5）若发生缺页，则进行缺页中断处理，将该页调入内存<br>（6）利用快表可以加速地址转换<br>3、页面置换算法、缺页率计算、LRU 算法的硬件实现方法、抖动、Belady 异常、缺页中断；<br>【典型题举例】<br>在页式虚拟存储管理的计算机系统中，运行一个共有 7 页的作业，且作业在主存中分配到 3 块主存空间，作业执行时访问页的顺序为 1, 2, 3, 4, 2, 1, 5, 6, 2, 1, 3, 7, 6, 3, 2, 1, 2, 3, 6。假设 3 个物理块初始为空，所有页面都采用请调式 LRU 替换算法，要求图示出内存页面变化情况，并计算缺页率。<br>(LRU)置换算法 :</p>
<p>某程序大小为 460 个字，考虑如下访问序列：10，11，104，170，73，309，189，245，246，434，458，364，页帧大小为 100 个字，请给出页面访问串（即页面走向）。<br>解:<br>页号＝逻辑地址&#x2F;页帧大小，所以访问串为：<br>0，0，1，1，0，3，1，2，2，4，4，3<br>也可简化为：0，1，0，3，1，2，4，3</p>
<p>4、虚拟内存下内存访问时间的计算；<br>【典型题举例】<br>没有快表的情况(设访存一次所需的时间为 t)：<br>查找页表找到对应页表项，需要访存一次;<br>通过对应页表项中的物理地址访问对应内存单元，需要访存一次;<br>因此，EAT&#x3D;t+t&#x3D;2t<br>有快表的情况：设访问快表的时间为 λ，快表的命中率为 a，则<br>EAT&#x3D;a(λ+t)+(1-a)(λ+t+λ+t)<br>对一个将页表存放在内存中的分页系统：<br>（1）若访问内存需要 0.2us，有效访问时间为多少？<br>（2）如果加一快表，且假定设置快表的命中率高达 90%，则有效内存访问时间又是多少？（快表查询需要时间忽略）。<br>分页系统要访问两次，第一次要访问页表，将页号换成页地址，并与偏移量相加，得出实际地址，第二次要访问实际的地址的，所以所用时间是 0.4μs，如果有快表，命中率为 90%，则访问时间为 0.2<em>90%+0.4</em>10%&#x3D;0.18+0.04&#x3D;0.22μs</p>
<p>第六章 设备管理<br>1、设备管理的任务、功能及目标；<br>完成用户提出的 I&#x2F;O 请求<br>提高 I&#x2F;O 速率<br>提高设备的利用率<br>为更高层的进程方便地使用这些设备提供手段。<br>2、I&#x2F;O 设备的分类，设备、控制器及通道的关系；<br>1.I&#x2F;O 设备的类型<br>★ 按使用特性分类<br>① 存储设备，也称外存、辅存，是用以存储信息的主要设备。该类设备存取速度较内存慢，但容量却大得多，价格也便宜。<br>②I&#x2F;O 设备，它又可分为输入设备、输出设备和交互式设备。<br>★ 按传输速率分类<br>① 低速设备：其传输速率仅为每秒钟几个字节至数百个字节的一类设备，如键盘、鼠标器。<br>② 中速设备：传输速率在每秒钟数千个字节至数十万个字节的一类设备，如行式打印机、激光打印机等。<br>③ 高速设备：传输速率在数十万字节至千兆字节的一类设备，如磁带机、磁盘机、光盘机等。</p>
<p>设备与控制器之间的接口<br>① 数据信号线：用于在设备和设备控制器之间传送数据信号。<br> ② 控制信号线：由设备控制器向 I&#x2F;O 设备发送控制信号时的通路。<br>③ 状态信号线：用于传送指示设备当前状态的信号。</p>
<p>3、通道的基本概念及分类；</p>
<p>虽然在 CPU 与 I&#x2F;O 设备之间增加了设备控制器后，已能大大减少 CPU 对 I&#x2F;O 的干预，但当主机所配置的外设很多时，CPU 的负担仍然很重。<br>CPU 和设备控制器之间又增设了通道。<br>目的:是使一些原来由 CPU 处理的 I&#x2F;O 任务转由通道来承担，从而把 CPU 从繁杂的 I&#x2F;O 任务中解脱出来。<br>　 2.通道类型<br>　　 1) 字节多路通道(Byte Multiplexor Channel) 2) 数组选择通道(Block Selector Channel) 3) 数组多路通道(Block Multiplexor Channel)</p>
<p>4、I&#x2F;O 控制方式及推动发展的因素、各自适用的场合；<br>I&#x2F;O 控制方式主要有<br>程序轮询方式:该方式采用用户程序直接控制主机与外部设备之间输入&#x2F;输出操作。CPU 必须不停地循环测试 I&#x2F;O 设备的状态端口，当发现设备处于准备好(Ready)状态时，CPU 就可以与 I&#x2F;O 设备进行数据存取操作。<br>中断方式:<br>当 I&#x2F;O 设备结束(完成、特殊或异常)时，就会向 CPU 发出中断请求信号，CPU 收到信号就可以采取相应措施。当某个进程要启动某个设备时，CPU 就向相应的设备控制器发出一条设备 I&#x2F;O 启动指令，然后 CPU 又返回做原来的工作。<br>DMA 方式:<br>DMA 方式也称为直接主存存取方式，其思想是：允许主存储器和 I&#x2F;O 设备之间通过“DMA 控制器(DMAC)”直接进行批量数据交换，除了在数据传输开始和结束时，整个过程无须 CPU 的干预。<br>I&#x2F;O 通道控制方式:<br>通道(Channel)也称为外围设备处理器、输入输出处理机，是相对于 CPU 而言的。是一个处理器。也能执行指令和由指令的程序，只不过通道执行的指令是与外部设备相关的指令。是一种实现主存与 I&#x2F;O 设备进行直接数据交换的控制方式。<br>5、缓冲区的概念、分类及引入目的；单缓冲、双缓冲计算处理数据的时间；</p>
<p>在单缓冲区中，当上一个磁盘块从缓冲区读入用户区完成时，下一个磁盘块才能开始读入，也就是当最后一块磁盘块读入一用户区完毕时所用时间为 150<em>10&#x3D;1500us，加上处理最后一个磁盘块的时间 50us,得 1550us。双缓冲区中，不存在等待磁盘块从缓冲区读入用户区的问题，10 个磁盘块可以连续从外存读入主存缓冲区，加上将最有一个磁盘块从缓冲区送到用户区的传输时间 50us 以及处理时间 50us,也就是 100</em>10+50+50&#x3D;1100us</p>
<p>【典型题目举例】<br> 某文件占 10 个磁盘块，现要把该文件磁盘块逐个读入主存缓冲区，并送用户区进行分析。假设一个缓冲区与一个磁盘块大小相同，把一个磁盘块读入缓冲区的时间为 100μs，将缓冲区的数据传送到用户区的时间是 50μs，CPU 对一块数据进行分析的时间为 50μs。试计算在单缓冲区和双缓冲区结构下，读入并分析该文件的时间分别是多少，并画图说明计算过程。<br>6、I&#x2F;O 软件的层次、各层主要功能、设备独立性的概念；<br>设备独立性是指用户程序独立于具体使用的物理设备的一种特性。<br>(I) 用户层 I&#x2F;O 软件，实现与用户交互的接口，用户可直接调用该层所提供的、与 IO 操作有关的库函数对设备进行操作。<br>(2) 设备独立性软件，用于实现用户程序与设备驱动器的统接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。<br>(3) 设备驱动程序，与硬回件直接相关，用于具体实现系统对设备发出的操作指令，驱动 I&#x2F;O 设备工作的驱动程序。<br>(4)中断处理程序，用于保存被中答断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断的进程。</p>
<p>7、SPOOLING 技术的概念、作用及 SPOOLING 系统的组成；<br> SPOOLing 技术是一类典型的虚拟设备技术,通常是用独占设备来模拟共享设备。（F）<br>操作系统在用户层中还提供了一些非常有用的程序，比如假脱机系统，以及在网络传输文件时常使用的守护进程等，它们是运行在内核之外的程序，但它们仍属于 I&#x2F;O 系统。<br>SPOOLING 的组成<br>主要有四部分：<br>(1).输入井和输出井。是磁盘上开辟的两个大存储空间。输入井模拟脱机输入的磁盘设备，输出井模拟脱机输出时的磁盘。<br>(2).输入缓冲区和输出缓冲区。输入缓冲区暂存由输入设备送来的数据，后送输入井；输出缓冲区暂存从输出井送来的数据，后送输出设备。<br>(3).输入进程和输出进程。利用两个进程模拟脱机 I&#x2F;O 时的外围处理机。<br>(4).井管理程序。用于控制作业与磁盘井之间信息的交换。</p>
<p>8、磁盘访问过程及访问时间的确定、块号与柱面、磁道、扇区号的对应关系、磁盘调度算法及其计算；扇区的优化；<br>(看输入输出 I&#x2F;O 第六章 145 页 ppt)<br>【典型题目举例】<br> 若磁头的当前位置为 100 柱面，磁头正向磁道号减小方向移动。现有一磁盘读写请求队列，柱面号依次为：190 , 10 , 160 , 80 , 90 , 125 , 30 , 20 , 29 , 140 , 25 。若采用电梯调度算法，试计算移臂经过的柱面数和平均寻道长度。</p>
<p>第七章 文件管理<br>1、文件系统的组成、功能；<br>文件系统由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性。<br>文件系统功能:<br>用户角度：<br>实现“按名存取”<br>系统角度：<br>文件存储空间的管理<br>文件的存储与检索<br>文件的共享与保护。</p>
<p>2、打开、关闭操作的目的；<br>把该文件的有关控制信息（ FCB ）读入内存，建立相应的数据结构，以建立用户和该文件的联系，方便读写,避免多次重复地检索目录，节省检索开销，提高操作速度。<br>文件描述符&#x2F;文件句柄。<br>3、文件逻辑结构；</p>
<p>文件逻辑结构的类型:<br>顺序文件<br>记录寻址<br>索引文件<br>索引顺序文件<br>直接文件和哈希文件</p>
<p>文件组织的两种观点<br>⑴ 用户观点（逻辑结构）<br>研究的是用户思维中的抽象文件，也叫逻辑文件。其目的是为用户提供一种结构清晰、使用简便的逻辑组织。用户按此去存储、检索和加工处理有关文件信息。<br>⑵ 实现观点（物理结构）<br>研究的是存储在物理设备介质上的实际文件，即物理文件。其目的是选择一些性能良好、设备利用率高的物理结构。系统按此和外部设备打交道，控制信息的传输。</p>
<p>逻辑结构分类<br>（1）是否有结构<br>① 有结构文件：由一个以上的记录构成的文件，<br>又称为记录式文件；<br>定长记录&#x2F;变长记录。<br>② 无结构文件：由字符流构成的文件，<br>又称为流式文件。<br>⑵ 文件的逻辑组织方式<br>① 顺序文件<br>② 索引文件<br>③ 索引顺序文件</p>
<p>4、文件的目录结构、索引节点及文件控制块的作用；<br> 如何加快目录检索？</p>
<p> 目录项分解法：即把 FCB 分成两部分，符号目录项：文件名，文件号，基本目录项：除文件名外的所有字段</p>
<p>5、了解文件的共享和保护措施。<br>第八章 磁盘存储器的管理<br>1、文件的物理结构；<br>常用的物理结构有连续文件结构、串联文件结构、索引文件结构三种。<br>2、 FAT 表的作用、FAT 表大小的计算；<br>FAT 技术<br>利用文件分配表 FAT 记录每个文件所有盘块之间的链接。<br>Windows NT、Windows 2000 和 Windows XP 操作系统则采用 NTFS(新技术文件系统)</p>
<p>【典型题目举例】<br>假设盘块大小为 512B，硬盘的大小为 100MB，如果采用显式链接管理方式，对应的 FAT 为多少字节？<br> 100MB&#x2F;512B&#x3D;200K 个块；<br> 需要 18 个二进制位来描述块号；<br> 按照 FAT 表的组织结构，每个表项需要扩充成 20 位即 2.5 个字节；<br> 所以 FAT 表的大小&#x3D;2.5B*200K&#x3D;500KB。<br>3、 混合索引分配方式的结构及相关计算；<br>【典型题目举例】<br> 某磁盘文件系统，采用混合索引分配方式，13 个地址项记录在 FCB 中，第 0-9 个地址项为直接地址，第 10 个地址项为一次间接地址，第 11 个地址项为二次间接地址，第 12 个地址项为三次间接地址。如果每个盘块的大小为 512 字节，盘块号需要用 3 个字节来描述，问：<br>1）该文件系统允许文件的最大长度是多少？<br>2）若要读取字节地址为 5000B 处的文件数据，试计算得到其映射到的物理地址（磁盘块号及偏移量），请写明计算过程。<br>4、文件空闲区的管理方法（空闲表、空闲链、位示图与成组链接法）；<br>【典型题目举例】<br>假设一个磁盘组有 100 个柱面，编号为 0-99，每个柱面有 32 个磁道，编号为 0-31，每个磁道有 16 个扇区，编号为 0-15。现采用位示图方法管理磁盘空间，磁盘块与扇区大小相等，令磁盘块号按柱面顺序和磁道顺序编排（从 0 编起）。请回答下列问题：（5 分） 1)若采用 32 位的字组成位示图，共需要多少个字? 2)第 40 字的第 18 位对应于哪个柱面、哪个读写磁头和哪个扇区? 1)（16×32×100）&#x2F;32&#x3D;1600,需要 1600 个字。<br>2）块号是 1298：40×32+18&#x3D;1298<br>柱面号是 2：[1298&#x2F;(16×32)]&#x3D;2<br>磁头号是 17：[（1298 mod (16×32)）&#x2F;16]&#x3D;17<br>扇区号是 2：（1298 mod （16×32））mod 16&#x3D;2<br> 某 UNIX 操作系统的空闲盘块号栈内容为：空闲块数为 3，依次登记的空闲块号为 77、89、60，问此时若一个文件 A 需要 5 个盘块，系统进行分配后又有个文件 B 被删除，它占用的盘块块号为 100、101、109、500，分析分配和回收过程，说明上述操作过后空闲盘块号栈里的空闲块个数及内容如何？<br>5、了解提高磁盘 I&#x2F;O 速度的途径。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>『操作系统』复习提纲</div>
      <div>https://chiamzhang.github.io/2024/06/29/『操作系统』复习提纲/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Chiam</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 29, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/29/%E3%80%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8F%E5%BE%AE%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%87%A0%E4%BD%95%EF%BC%9F(%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%89/" title="『操作系统』微内核结构的操作系统几何？(优缺点）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">『操作系统』微内核结构的操作系统几何？(优缺点）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/29/%E3%80%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%99%9A%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E4%B9%8B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" title="『操作系统』内存管理-虚页面管理之页面置换算法">
                        <span class="hidden-mobile">『操作系统』内存管理-虚页面管理之页面置换算法</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"fIfc7WqUDZohlQuPc2lz5mJy-MdYXbMMI","appKey":"zjlAG3ZA3o4cBHVAkjzc2Z20","path":"window.location.pathname","placeholder":"留言仅限讨论，禁止广告等行为","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://fifc7wqu.api.lncldglobal.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <meta name="referrer" content="no-referrer" /> <footer id="footer" role="contentinfo"> <meta name="referrer" content="no-referrer" /> <div class="divider"> <div class="wall"></div> <img class="animals" src="/img/footer_animals_new.png" srcset="/img/loading.gif" lazyload alt="Footer Animals"> </div> <div class="container" data-index="450"> <p> <a href="https://chiamzhang.github.io" target="_blank">DogEgg</a> <i class="iconfont icon-love"></i> <a href="#" target="_blank">LittePig</a> </p> <p> Powered by  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-pen"></i> Theme  <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </p> </div> </footer> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/love.js"></script>
<script src="/js/funnyTitle.js"></script>
<script src="/js/backTop.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxuehua.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
