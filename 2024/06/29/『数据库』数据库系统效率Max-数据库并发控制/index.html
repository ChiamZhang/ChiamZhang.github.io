

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Mine.jpg">
  <link rel="icon" href="/img/Mine.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Chiam">
  <meta name="keywords" content="Algorithms，Cybersecurity">
  
    <meta name="description" content="『数据库』数据库系统效率 Max-数据库并发控制数据库从入门到精通：戳我@[toc] 简介1. 多用户数据库系统允许多个用户同时使用的数据库系统 -飞机定票数据库系统  银行数据库系统 特点：在同一时刻并发运行的事务数可达数百上千个  2.多事务执行方式2.1 事务串行执行 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行 不能充分利用系统资源，发挥数据库共享资源的特点  2.2">
<meta property="og:type" content="article">
<meta property="og:title" content="『数据库』数据库系统效率Max-数据库并发控制">
<meta property="og:url" content="https://chiamzhang.github.io/2024/06/29/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%95%88%E7%8E%87Max-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="Blogs of 风骨散人Chiam">
<meta property="og:description" content="『数据库』数据库系统效率 Max-数据库并发控制数据库从入门到精通：戳我@[toc] 简介1. 多用户数据库系统允许多个用户同时使用的数据库系统 -飞机定票数据库系统  银行数据库系统 特点：在同一时刻并发运行的事务数可达数百上千个  2.多事务执行方式2.1 事务串行执行 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行 不能充分利用系统资源，发挥数据库共享资源的特点  2.2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612213220868.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612213322264.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020061221402841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612214202813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612214403753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612214840453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612215226686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612215415605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612215504436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_10,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612215643268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612215746866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612215901755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612220502939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612220850957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612220919626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612220943436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612221007240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612221249680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612221600266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612221717765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612222012958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612222419987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200612222449675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2024-06-29T13:16:53.863Z">
<meta property="article:modified_time" content="2023-12-05T16:18:13.569Z">
<meta property="article:author" content="Chiam">
<meta property="article:tag" content="Algorithms，Cybersecurity">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200612213220868.png">
  
  
  
  <title>『数据库』数据库系统效率Max-数据库并发控制 - Blogs of 风骨散人Chiam</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"chiamzhang.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>风骨散人Chiam Blogs</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="『数据库』数据库系统效率Max-数据库并发控制"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-29 21:16" pubdate>
          June 29, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.2k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          69 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">『数据库』数据库系统效率Max-数据库并发控制</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="『数据库』数据库系统效率-Max-数据库并发控制"><a href="#『数据库』数据库系统效率-Max-数据库并发控制" class="headerlink" title="『数据库』数据库系统效率 Max-数据库并发控制"></a>『数据库』数据库系统效率 Max-数据库并发控制</h1><p>数据库从入门到精通：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43627118/article/details/105027257">戳我</a><br>@[toc]</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="1-多用户数据库系统"><a href="#1-多用户数据库系统" class="headerlink" title="1. 多用户数据库系统"></a>1. 多用户数据库系统</h4><p>允许多个用户同时使用的数据库系统 -飞机定票数据库系统</p>
<ul>
<li>银行数据库系统</li>
<li>特点：在同一时刻并发运行的事务数可达数百上千个</li>
</ul>
<h4 id="2-多事务执行方式"><a href="#2-多事务执行方式" class="headerlink" title="2.多事务执行方式"></a>2.多事务执行方式</h4><h5 id="2-1-事务串行执行"><a href="#2-1-事务串行执行" class="headerlink" title="2.1 事务串行执行"></a>2.1 事务串行执行</h5><ul>
<li>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行</li>
<li>不能充分利用系统资源，发挥数据库共享资源的特点<br><img src="https://img-blog.csdnimg.cn/20200612213220868.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
</ul>
<h5 id="2-2-交叉并发方式（Interleaved-Concurrency）"><a href="#2-2-交叉并发方式（Interleaved-Concurrency）" class="headerlink" title="2.2 交叉并发方式（Interleaved Concurrency）"></a>2.2 交叉并发方式（Interleaved Concurrency）</h5><ul>
<li>在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行</li>
<li>单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200612213322264.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h5 id="2-3-同时并发方式（simultaneous-concurrency）"><a href="#2-3-同时并发方式（simultaneous-concurrency）" class="headerlink" title="2.3 同时并发方式（simultaneous concurrency）"></a>2.3 同时并发方式（simultaneous concurrency）</h5><ul>
<li>多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行</li>
<li>最理想的并发方式，但受制于硬件环境</li>
<li>更复杂的并发方式机制</li>
</ul>
<p><strong>本章讨论的数据库系统并发控制技术是以单处理机系统为基础的</strong></p>
<h5 id="2-4-事务并发执行带来的问题"><a href="#2-4-事务并发执行带来的问题" class="headerlink" title="2.4 事务并发执行带来的问题"></a>2.4 事务并发执行带来的问题</h5><ul>
<li>会产生多个事务同时存取同一数据的情况</li>
<li>可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性</li>
</ul>
<p><strong>数据库管理系统必须提供并发控制机制</strong><br><strong>并发控制机制是衡量一个数据库管理系统性能的重要标志之一</strong></p>
<h3 id="1-并发控制概述"><a href="#1-并发控制概述" class="headerlink" title="1 并发控制概述"></a>1 并发控制概述</h3><p><strong>事务是并发控制的基本单位<br>并发控制机制的任务</strong></p>
<ul>
<li>对并发操作进行正确调度</li>
<li>保证事务的隔离性</li>
<li>保证数据库的一致性</li>
</ul>
<p><strong>并发操作带来数据的不一致性实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">[例<span class="hljs-number">11.1</span>]飞机订票系统中的一个活动序列<br>① 甲售票点(事务T1)读出某航班的机票余额A，设A=<span class="hljs-number">16</span>；<br>② 乙售票点(事务T2)读出同一航班的机票余额A，也为<span class="hljs-number">16</span>；<br>③ 甲售票点卖出一张机票，修改余额A←A-<span class="hljs-number">1</span>，所以A为<span class="hljs-number">15</span>，把A写回数据库；<br>④ 乙售票点也卖出一张机票，修改余额A←A-<span class="hljs-number">1</span>，所以A为<span class="hljs-number">15</span>，把A写回数据库<br>结果明明卖出两张机票，数据库中机票余额只减少<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<ul>
<li>这种情况称为数据库的不一致性，是由并发操作引起的。</li>
<li>在并发操作情况下，对 T1、T2 两个事务的操作序列的调度是随机的。</li>
<li>若按上面的调度序列执行，T1 事务的修改就被丢失。</li>
<li>原因：第 4 步中 T2 事务修改 A 并写回后覆盖了 T1 事务的修改</li>
</ul>
<p><strong>并发操作带来的数据不一致性</strong></p>
<ul>
<li>1.丢失修改（Lost Update）</li>
<li>2.不可重复读（Non-repeatable Read）</li>
<li>3.读“脏”数据（Dirty Read）</li>
</ul>
<p><strong>记号</strong></p>
<ul>
<li>R(x):读数据 x</li>
<li>W(x):写数据 x</li>
</ul>
<h4 id="1-1-修改丢失"><a href="#1-1-修改丢失" class="headerlink" title="1.1 修改丢失"></a>1.1 修改丢失</h4><p>两个事务 T1 和 T2 读入同一数据并修改，T2 的提交结果破坏了 T1 提交的结果，导致 T1 的修改被丢失。<br>上面飞机订票例子就属此类<br><img src="https://img-blog.csdnimg.cn/2020061221402841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="1-2-不可重复读"><a href="#1-2-不可重复读" class="headerlink" title="1.2 不可重复读"></a>1.2 不可重复读</h4><p>不可重复读是指事务 T1 读取数据后，事务 T2 执行更新操作，使 T1 无法再现前一次读取结果。<br><strong>不可重复读包括三种情况：</strong></p>
<ul>
<li>1.事务 T1 读取某一数据后，事务 T2 对其做了修改，当事务 T1 再次读该数据时，得到与前一次不同的值<br><img src="https://img-blog.csdnimg.cn/20200612214202813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"> - T1 读取 B&#x3D;100 进行运算 - T2 读取同一数据 B，对其进行修改后将 B&#x3D;200 写回数据库。 - T1 为了对读取值校对重读 B，B 已为 200，与第一次读取值不一致</li>
<li>2.事务 T1 按一定条件从数据库中读取了某些数据记录后，事务 T2 删除了其中部分记录，当 T1 再次按相同条件读取数据时，发现某些记录神秘地消失了。</li>
<li>3.事务 T1 按一定条件从数据库中读取某些数据记录后，事务 T2 插入了一些记录，当 T1 再次按相同条件读取数据时，发现多了一些记录。<br>后两种不可重复读有时也称为幻影现象（Phantom Row）</li>
</ul>
<h4 id="1-3-读“脏”数据"><a href="#1-3-读“脏”数据" class="headerlink" title="1.3 读“脏”数据"></a>1.3 读“脏”数据</h4><ul>
<li>事务 T1 修改某一数据，并将其写回磁盘</li>
<li>事务 T2 读取同一数据后，T1 由于某种原因被撤销</li>
<li>这时 T1 已修改过的数据恢复原值，T2 读到的数据就与数据库中的数据不一致</li>
<li>T2 读到的数据就为“脏”数据，即不正确的数据<br><img src="https://img-blog.csdnimg.cn/20200612214403753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
<li>T1 将 C 值修改为 200，T2 读到 C 为 200</li>
<li>T1 由于某种原因撤销，其修改作废，C 恢复原值 100</li>
<li>这时 T2 读到的 C 为 200，与数据库内容不一致，就是“脏”数据</li>
</ul>
<p><strong>数据不一致性：由于并发操作破坏了事务的隔离性</strong></p>
<p><strong>并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性</strong></p>
<p><strong>对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销</strong></p>
<p><strong>并发控制的主要技术</strong></p>
<ul>
<li>封锁(Locking)</li>
<li>时间戳(Timestamp)</li>
<li>乐观控制法</li>
<li>多版本并发控制(MVCC)</li>
</ul>
<h3 id="2-封锁"><a href="#2-封锁" class="headerlink" title="2 封锁"></a>2 封锁</h3><h4 id="2-1-什么是封锁"><a href="#2-1-什么是封锁" class="headerlink" title="2.1 什么是封锁"></a>2.1 什么是封锁</h4><ul>
<li>封锁就是事务 T 在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</li>
<li>加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其它的事务不能更新此数据对象。</li>
<li>封锁是实现并发控制的一个非常重要的技术</li>
</ul>
<h4 id="2-2-基本封锁类型"><a href="#2-2-基本封锁类型" class="headerlink" title="2.2 基本封锁类型"></a>2.2 基本封锁类型</h4><p>一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。<br><strong>基本封锁类型</strong></p>
<ul>
<li><p>排它锁（Exclusive Locks，简记为 X 锁）<br>排它锁又称为写锁<br>若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其它任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁<br>保证其他事务在 T 释放 A 上的锁之前不能再读取和修改 A</p>
</li>
<li><p>共享锁（Share Locks，简记为 S 锁）<br>共享锁又称为读锁<br>若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其它事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁<br>保证其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改</p>
</li>
</ul>
<h4 id="2-3-锁的相容矩阵"><a href="#2-3-锁的相容矩阵" class="headerlink" title="2.3 锁的相容矩阵"></a>2.3 锁的相容矩阵</h4><p><img src="https://img-blog.csdnimg.cn/20200612214840453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>Y&#x3D;Yes，相容的请求(可同时进行）<br>N&#x3D;No，不相容的请求（不可同时进行）</p>
<p><strong>在锁的相容矩阵中：</strong></p>
<p>最左边一列表示事务 T1 已经获得的数据对象上的锁的类型，其中横线表示没有加锁。</p>
<p>最上面一行表示另一事务 T2 对同一数据对象发出的封锁请求。</p>
<ul>
<li>T2 的封锁请求能否被满足用矩阵中的 Y 和 N 表示</li>
<li>Y 表示事务 T2 的封锁要求与 T1 已持有的锁相容，封锁请求可以满足</li>
<li>N 表示 T2 的封锁请求与 T1 已持有的锁冲突，T2 的请求被拒绝</li>
</ul>
<h3 id="3-封锁协议"><a href="#3-封锁协议" class="headerlink" title="3 封锁协议"></a>3 封锁协议</h3><h4 id="3-1-什么是封锁协议"><a href="#3-1-什么是封锁协议" class="headerlink" title="3.1 什么是封锁协议"></a>3.1 什么是封锁协议</h4><ul>
<li>在运用 X 锁和 S 锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。<ul>
<li>何时申请 X 锁或 S 锁</li>
<li>持锁时间</li>
<li>何时释放</li>
</ul>
</li>
<li>对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。</li>
</ul>
<h4 id="3-2-三级封锁协议"><a href="#3-2-三级封锁协议" class="headerlink" title="3.2 三级封锁协议"></a>3.2 三级封锁协议</h4><h5 id="3-2-1-一级封锁协议"><a href="#3-2-1-一级封锁协议" class="headerlink" title="3.2.1. 一级封锁协议"></a>3.2.1. 一级封锁协议</h5><p>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。</p>
<ul>
<li>正常结束（COMMIT）</li>
<li>非正常结束（ROLLBACK）</li>
</ul>
<p>一级封锁协议可防止丢失修改，并保证事务 T 是可恢复的。<br>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。</p>
<p><strong>使用封锁机制解决丢失修改问题</strong><br><img src="https://img-blog.csdnimg.cn/20200612215226686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li>事务 T1 在读 A 进行修改之前先对 A 加 X 锁</li>
<li>当 T2 再请求对 A 加 X 锁时被拒绝</li>
<li>T2 只能等待 T1 释放 A 上的锁后获得对 A 的 X 锁</li>
<li>这时 T2 读到的 A 已经是 T1 更新过的值 15</li>
<li>T2 按此新的 A 值进行运算，并将结果值 A&#x3D;14 写回到磁盘。避免了丢失 T1 的更新。</li>
</ul>
<h5 id="3-2-2-二级封锁协议"><a href="#3-2-2-二级封锁协议" class="headerlink" title="3.2.2. 二级封锁协议"></a>3.2.2. 二级封锁协议</h5><ul>
<li><p>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。</p>
</li>
<li><p>二级封锁协议可以防止丢失修改和读“脏”数据。</p>
</li>
<li><p>在二级封锁协议中，由于读完数据后即可释放 S 锁，所以它不能保证可重复读。</p>
</li>
</ul>
<p><strong>使用封锁机制解决读“脏”数据问题</strong><br><img src="https://img-blog.csdnimg.cn/20200612215415605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li>事务 T1 在对 C 进行修改之前，先对 C 加 X 锁，修改其值后写回磁盘</li>
<li>T2 请求在 C 上加 S 锁，因 T1 已在 C 上加了 X 锁，T2 只能等待</li>
<li>T1 因某种原因被撤销，C 恢复为原值 100</li>
<li>T1 释放 C 上的 X 锁后 T2 获得 C 上的 S 锁，读 C&#x3D;100。避免了 T2 读“脏”数据</li>
</ul>
<h5 id="3-2-3-三级封锁协议"><a href="#3-2-3-三级封锁协议" class="headerlink" title="3.2.3. 三级封锁协议"></a>3.2.3. 三级封锁协议</h5><ul>
<li>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</li>
<li>三级封锁协议可防止丢失修改、读脏数据和不可重复读。<br><img src="https://img-blog.csdnimg.cn/20200612215504436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_10,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
<li>事务 T1 在读 A，B 之前，先对 A，B 加 S 锁</li>
<li>其他事务只能再对 A，B 加 S 锁，而不能加 X 锁，即其他事务只能读 A，B，而不能修改</li>
<li>当 T2 为修改 B 而申请对 B 的 X 锁时被拒绝只能等待 T1 释放 B 上的锁</li>
<li>T1 为验算再读 A，B，这时读出的 B 仍是 100，求和结果仍为 150，即可重复读</li>
<li>T1 结束才释放 A，B 上的 S 锁。T2 才获得对 B 的 X 锁</li>
</ul>
<h5 id="3-2-4-封锁协议小结"><a href="#3-2-4-封锁协议小结" class="headerlink" title="3.2.4 封锁协议小结"></a>3.2.4 封锁协议小结</h5><p>三级协议的主要区别</p>
<ul>
<li>什么操作需要申请封锁以及何时释放锁（即持锁时间）</li>
</ul>
<p>不同的封锁协议使事务达到的一致性级别不同</p>
<ul>
<li>封锁协议级别越高，一致性程度越高</li>
</ul>
<p><strong>不同级别的封锁协议和一致性保证</strong><br><img src="https://img-blog.csdnimg.cn/20200612215643268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="4-活锁和死锁"><a href="#4-活锁和死锁" class="headerlink" title="4 活锁和死锁"></a>4 活锁和死锁</h3><h4 id="4-1-活锁"><a href="#4-1-活锁" class="headerlink" title="4.1 活锁"></a>4.1 活锁</h4><ul>
<li>事务 T1 封锁了数据 R</li>
<li>事务 T2 又请求封锁 R，于是 T2 等待。</li>
<li>T3 也请求封锁 R，当 T1 释放了 R 上的封锁之后系统首先批准了 T3 的请求，T2 仍然等待。</li>
<li>T4 又请求封锁 R，当 T3 释放了 R 上的封锁之后系统又批准了 T4 的请求……</li>
<li>T2 有可能永远等待，这就是活锁的情形<br><img src="https://img-blog.csdnimg.cn/20200612215746866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>避免活锁：采用先来先服务的策略</strong></li>
<li>当多个事务请求封锁同一数据对象时</li>
<li>按请求封锁的先后次序对这些事务排队</li>
<li>该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁</li>
</ul>
<h4 id="4-2-死锁"><a href="#4-2-死锁" class="headerlink" title="4.2 死锁"></a>4.2 死锁</h4><ul>
<li>事务 T1 封锁了数据 R1</li>
<li>T2 封锁了数据 R2</li>
<li>T1 又请求封锁 R2，因 T2 已封锁了 R2，于是 T1 等待 T2 释放 R2 上的锁</li>
<li>接着 T2 又申请封锁 R1，因 T1 已封锁了 R1，T2 也只能等待 T1 释放 R1 上的锁</li>
<li>这样 T1 在等待 T2，而 T2 又在等待 T1，T1 和 T2 两个事务永远不能结束，形成死锁<br><img src="https://img-blog.csdnimg.cn/20200612215901755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
</ul>
<p><strong>解决死锁的方法：</strong></p>
<h5 id="4-2-1-死锁的预防"><a href="#4-2-1-死锁的预防" class="headerlink" title="4.2.1. 死锁的预防"></a>4.2.1. 死锁的预防</h5><ul>
<li>产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。</li>
<li>预防死锁的发生就是要破坏产生死锁的条件</li>
</ul>
<h6 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h6><p><strong>1. 一次封锁法</strong><br>要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行<br><strong>存在的问题</strong></p>
<ul>
<li>降低系统并发度</li>
<li>难于事先精确确定封锁对象<ul>
<li>数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象。</li>
<li>解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。</li>
</ul>
</li>
</ul>
<p><strong>2. 顺序封锁法</strong><br><strong>顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</strong></p>
<p><strong>顺序封锁法存在的问题</strong></p>
<ul>
<li>维护成本<br>数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。</li>
<li>难以实现<br>事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁<br><strong>3.结论</strong></li>
<li>在操作系统中广为采用的预防死锁的策略并不太适合数据库的特点</li>
<li>数据库管理系统在解决死锁的问题上更普遍采用的是诊断并解除死锁的方法</li>
</ul>
<h5 id="4-2-2-死锁的诊断与解除"><a href="#4-2-2-死锁的诊断与解除" class="headerlink" title="4.2.2. 死锁的诊断与解除"></a>4.2.2. 死锁的诊断与解除</h5><h6 id="1-超时法诊断"><a href="#1-超时法诊断" class="headerlink" title="1.超时法诊断"></a>1.超时法诊断</h6><p>如果一个事务的等待时间超过了规定的时限，就认为发生了死锁<br><strong>优点</strong>：实现简单<br><strong>缺点</strong></p>
<ul>
<li>有可能误判死锁</li>
<li>时限若设置得太长，死锁发生后不能及时发现</li>
</ul>
<h6 id="2-等待图法诊断"><a href="#2-等待图法诊断" class="headerlink" title="2.等待图法诊断"></a>2.等待图法诊断</h6><p>用事务等待图动态反映所有事务的等待情况</p>
<ul>
<li>事务等待图是一个有向图 G&#x3D;(T，U)</li>
<li>T 为结点的集合，每个结点表示正运行的事务</li>
<li>U 为边的集合，每条边表示事务等待的情况</li>
<li>若 T1 等待 T2，则 T1，T2 之间划一条有向边，从 T1 指向 T2<br><img src="https://img-blog.csdnimg.cn/20200612220502939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
<li>图(a)中，事务 T1 等待 T2，T2 等待 T1，产生了死锁</li>
<li>图(b)中，事务 T1 等待 T2，T2 等待 T3，T3 等待 T4，T4 又等待 T1，产生了死锁</li>
<li>图(b)中，事务 T3 可能还等待 T2，在大回路中又有小的回路</li>
</ul>
<p>并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。</p>
<h6 id="3-解除死锁"><a href="#3-解除死锁" class="headerlink" title="3.解除死锁"></a>3.解除死锁</h6><ul>
<li>选择一个处理死锁代价最小的事务，将其撤消</li>
<li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li>
</ul>
<h3 id="5-并发调度的可串行性"><a href="#5-并发调度的可串行性" class="headerlink" title="5 并发调度的可串行性"></a>5 并发调度的可串行性</h3><ul>
<li>数据库管理系统对并发事务不同的调度可能会产生不同的结果</li>
<li>串行调度是正确的</li>
<li>执行结果等价于串行调度的调度也是正确的，称为可串行化调度</li>
</ul>
<h4 id="5-1-可串行化调度"><a href="#5-1-可串行化调度" class="headerlink" title="5.1&#x3D;&#x3D;可串行化调度&#x3D;&#x3D;"></a>5.1&#x3D;&#x3D;可串行化调度&#x3D;&#x3D;</h4><p>可串行化(Serializable)调度</p>
<ul>
<li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li>
</ul>
<p>可串行性(Serializability)</p>
<ul>
<li>是并发事务正确调度的准则</li>
<li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li>
</ul>
<p>例：现在有两个事务，分别包含下列操作：<br>事务 T1：读 B；A&#x3D;B+1；写回 A<br>事务 T2：读 A；B&#x3D;A+1；写回 B<br><strong>现给出对这两个事务不同的调度策略</strong><br><img src="https://img-blog.csdnimg.cn/20200612220850957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li>假设 A、B 的初值均为 2。</li>
<li>按 T1→T2 次序执行结果为 A&#x3D;3，B&#x3D;4</li>
<li>串行调度策略,正确的调度</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200612220919626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li>假设 A、B 的初值均为 2。</li>
<li>T2→T1 次序执行结果为 B&#x3D;3，A&#x3D;4</li>
<li>串行调度策略,正确的调度<br><img src="https://img-blog.csdnimg.cn/20200612220943436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
<li>执行结果与(a)、(b)的结果都不同</li>
<li>是错误的调度<br><img src="https://img-blog.csdnimg.cn/20200612221007240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
<li>执行结果与串行调度(a)的执行结果相同</li>
<li>是正确的调度</li>
</ul>
<h4 id="5-1-冲突可串行化调度"><a href="#5-1-冲突可串行化调度" class="headerlink" title="5.1 冲突可串行化调度"></a>5.1 冲突可串行化调度</h4><ul>
<li>一个比可串行化更严格的条件</li>
<li>商用系统中的调度器采用</li>
</ul>
<p>冲突操作：是指不同的事务对同一数据的读写操作和写写操作：<br>Ri(x)与 Wj(x) &#x2F;<em>事务 Ti 读 x，Tj 写 x，其中 i≠j</em>&#x2F;<br>Wi(x)与 Wj(x) &#x2F;<em>事务 Ti 写 x，Tj 写 x，其中 i≠j</em>&#x2F;<br>其他操作是不冲突操作</p>
<p>不能交换（Swap）的动作:</p>
<ul>
<li><p>同一事务的两个操作</p>
</li>
<li><p>不同事务的冲突操作</p>
</li>
<li><p>一个调度 Sc 在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 Sc’，如果 Sc’是串行的，称调度 Sc 是冲突可串行化的调度</p>
</li>
<li><p>若一个调度是冲突可串行化，则一定是可串行化的调度</p>
</li>
<li><p>可用这种方法判断一个调度是否是冲突可串行化的<br><img src="https://img-blog.csdnimg.cn/20200612221249680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
</li>
</ul>
<p>冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。<br><strong>[例]</strong> 有 3 个事务<br>T1&#x3D;W1(Y)W1(X)，T2&#x3D;W2(Y)W2(X)，T3&#x3D;W3(X)<br>调度 L1&#x3D;W1(Y)W1(X)W2(Y)W2(X) W3(X)是一个串行调度。<br>调度 L2&#x3D;W1(Y)W2(Y)W2(X)W1(X)W3(X)不满足冲突可串行化。但是调度 L2 是可串行化的，因为 L2 执行的结果与调度 L1 相同，Y 的值都等于 T2 的值，X 的值都等于 T3 的值</p>
<h3 id="6-两段锁协议"><a href="#6-两段锁协议" class="headerlink" title="6 两段锁协议"></a>6 两段锁协议</h3><p><strong>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性</strong></p>
<p>指所有事务必须分两个阶段对数据项加锁和解锁</p>
<ul>
<li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li>
</ul>
<p><strong>“两段”锁的含义</strong></p>
<ul>
<li>事务分为两个阶段 - 第一阶段是获得封锁，也称为扩展阶段<br>事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁 - 第二阶段是释放封锁，也称为收缩阶段<br>事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</li>
</ul>
<p><strong>例</strong><br>事务 Ti 遵守两段锁协议，其封锁序列是 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Slock A    Slock B    Xlock C     Unlock B    Unlock A   Unlock C；<br>|←	   	    扩展阶段	       →|	|←	         收缩阶段               →|<br>事务Tj不遵守两段锁协议，其封锁序列是：<br>Slock A    Unlock A    Slock B    Xlock C    Unlock C    Unlock B；<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200612221600266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>左图的调度是遵守两段锁协议的，因此一定是一个可行化调度。<br>如何验证？</p>
<ul>
<li>事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。</li>
<li>若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的</li>
<li>若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议</li>
</ul>
<p><strong>两段锁协议与防止死锁的一次封锁法</strong></p>
<ul>
<li>一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议</li>
<li>但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁<br><strong>遵守两段锁协议的事务可能 发生死锁</strong><br><img src="https://img-blog.csdnimg.cn/20200612221717765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
</ul>
<h3 id="7-封锁的粒度"><a href="#7-封锁的粒度" class="headerlink" title="7 封锁的粒度"></a>7 封锁的粒度</h3><p><strong>封锁对象的大小称为封锁粒度(Granularity)</strong></p>
<p><strong>封锁的对象:逻辑单元，物理单元</strong><br>例：在关系数据库中，封锁对象：</p>
<ul>
<li>逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等</li>
<li>物理单元：页（数据页或索引页）、物理记录等</li>
</ul>
<p><strong>封锁粒度与系统的并发度和并发控制的开销密切相关</strong></p>
<ul>
<li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li>
<li>封锁的粒度越小，并发度较高，但系统开销也就越大</li>
</ul>
<p><strong>例</strong><br>若封锁粒度是数据页，事务 T1 需要修改元组 L1，则 T1 必须对包含 L1 的整个数据页 A 加锁。如果 T1 对 A 加锁后事务 T2 要修改 A 中元组 L2，则 T2 被迫等待，直到 T1 释放 A。<br>如果封锁粒度是元组，则 T1 和 T2 可以同时对 L1 和 L2 加锁，不需要互相等待，提高了系统的并行度。<br>又如，事务 T 需要读取整个表，若封锁粒度是元组，T 必须对表中的每一个元组加锁，开销极大</p>
<h5 id="多粒度封锁-Multiple-Granularity-Locking"><a href="#多粒度封锁-Multiple-Granularity-Locking" class="headerlink" title="多粒度封锁(Multiple Granularity Locking)"></a>多粒度封锁(Multiple Granularity Locking)</h5><p>在一个系统中同时支持多种封锁粒度供不同的事务选择</p>
<p><strong>选择封锁粒度</strong><br>同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度</p>
<ul>
<li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li>
<li>需要处理大量元组的用户事务：以关系为封锁单元</li>
<li>只处理少量元组的用户事务：以元组为封锁单位</li>
</ul>
<h5 id="7-1-多粒度封锁"><a href="#7-1-多粒度封锁" class="headerlink" title="7.1 多粒度封锁"></a>7.1 多粒度封锁</h5><p>多粒度树<br>以树形结构来表示多级封锁粒度<br>根结点是整个数据库，表示最大的数据粒度<br>叶结点表示最小的数据粒度</p>
<p>三级粒度树。根结点为数据库，数据库的子结点为关系，关系的子结点为元组。<br><img src="https://img-blog.csdnimg.cn/20200612222012958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>多粒度封锁协议</strong></p>
<ul>
<li>允许多粒度树中的每个结点被独立地加锁</li>
<li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁</li>
<li>在多粒度封锁中一个数据对象可能以两种方式封锁：<strong>显式封锁和隐式封锁</strong></li>
</ul>
<p><strong>显式封锁和隐式封锁</strong></p>
<ul>
<li>显式封锁: 直接加到数据对象上的封锁</li>
<li>隐式封锁:是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁</li>
<li>显式封锁和隐式封锁的效果是一样的<br><strong>系统检查封锁冲突时</strong></li>
<li>要检查显式封锁</li>
<li>还要检查隐式封锁</li>
</ul>
<p><strong>例如事务 T 要对关系 R1 加 X 锁</strong><br>系统必须搜索其上级结点数据库、关系 R1<br>还要搜索 R1 的下级结点，即 R1 中的每一个元组<br>如果其中某一个数据对象已经加了不相容锁，则 T 必须等待</p>
<p><strong>对某个数据对象加锁，系统要检查</strong></p>
<ul>
<li>该数据对象<br>有无显式封锁与之冲突</li>
<li>所有上级结点<br>检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的）</li>
<li>所有下级结点<br>看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突</li>
</ul>
<h5 id="7-2-意向锁"><a href="#7-2-意向锁" class="headerlink" title="7.2 意向锁"></a>7.2 意向锁</h5><p><strong>引进意向锁（intention lock）目的</strong></p>
<ul>
<li>提高对某个数据对象加锁时系统的检查效率</li>
</ul>
<p>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁<br>对任一结点加基本锁，必须先对它的上层结点加意向锁<br>例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁</p>
<p><strong>常用意向锁</strong></p>
<ul>
<li><p>意向共享锁(Intent Share Lock，简称 IS 锁)<br>如果对一个数据对象加 IS 锁，表示它的后裔结点拟（意向）加 S 锁。<br>例如：事务 T1 要对 R1 中某个元组加 S 锁，则要首先对关系 R1 和数据库加 IS 锁</p>
</li>
<li><p>意向排它锁(Intent Exclusive Lock，简称 IX 锁)<br>如果对一个数据对象加 IX 锁，表示它的后裔结点拟（意向）加 X 锁。<br>例如：事务 T1 要对 R1 中某个元组加 X 锁，则要首先对关<br> 系 R1 和数据库加 IX 锁</p>
</li>
<li><p>共享意向排它锁(Share Intent Exclusive Lock，简称 SIX 锁)<br>如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁，即 SIX &#x3D; S + IX。<br>例：对某个表加 SIX 锁，则表示该事务要读整个表（所以要对该表加 S 锁），同时会更新个别元组（所以要对该表加 IX 锁）。<br><img src="https://img-blog.csdnimg.cn/20200612222419987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>锁的强度</strong></p>
<ul>
<li>锁的强度是指它对其他锁的排斥程度</li>
<li>一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然<br><img src="https://img-blog.csdnimg.cn/20200612222449675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNzExOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>具有意向锁的多粒度封锁方法</strong></li>
<li>申请封锁时应该按自上而下的次序进行</li>
<li>释放封锁时则应该按自下而上的次序进行</li>
</ul>
<p>例如：事务 T1 要对关系 R1 加 S 锁</p>
<ul>
<li>要首先对数据库加 IS 锁</li>
<li>检查数据库和 R1 是否已加了不相容的锁(X 或 IX)</li>
<li>不再需要搜索和检查 R1 中的元组是否加了不相容的锁(X 锁)</li>
</ul>
<p>具有意向锁的多粒度封锁方法</p>
<ul>
<li>提高了系统的并发度</li>
<li>减少了加锁和解锁的开销</li>
<li>在实际的数据库管理系统产品中得到广泛应用</li>
</ul>
<h3 id="8-其他并发控制机制（略）"><a href="#8-其他并发控制机制（略）" class="headerlink" title="8 其他并发控制机制（略）"></a>8 其他并发控制机制（略）</h3><h3 id="9-小结"><a href="#9-小结" class="headerlink" title="9 小结"></a>9 小结</h3><p>数据库的并发控制以事务为单位<br>数据库的并发控制通常使用封锁机制</p>
<ul>
<li>基本封锁</li>
<li>多粒度封锁</li>
</ul>
<p>活锁和死锁<br>并发事务调度的正确性</p>
<ul>
<li>可串行性<ul>
<li>并发操作的正确性则通常由两段锁协议来保证。</li>
<li>两段锁协议是可串行化调度的充分条件，但不是必要条件</li>
</ul>
</li>
<li>冲突可串行性</li>
</ul>
<p>其他并发控制机制</p>
<ul>
<li>时间戳方法</li>
<li>乐观控制法</li>
<li>多版本并发控制</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>『数据库』数据库系统效率Max-数据库并发控制</div>
      <div>https://chiamzhang.github.io/2024/06/29/『数据库』数据库系统效率Max-数据库并发控制/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Chiam</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 29, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/29/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B%EF%BC%88%E6%A6%82%E5%BF%B5%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%8C%E5%BA%94%E7%94%A8%E4%B8%80%E8%88%AC%EF%BC%8C%E7%94%9A%E8%87%B3%E6%9C%89%E7%82%B9%E8%BF%87%E6%97%B6%EF%BC%8C%E7%94%A8%E6%9D%A5%E8%80%83%E8%AF%95%EF%BC%89/" title="『数据库』数据库编程（概念性的东西，应用一般，甚至有点过时，用来考试）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">『数据库』数据库编程（概念性的东西，应用一般，甚至有点过时，用来考试）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/29/%E3%80%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="『数据库』数据库笔记">
                        <span class="hidden-mobile">『数据库』数据库笔记</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"fIfc7WqUDZohlQuPc2lz5mJy-MdYXbMMI","appKey":"zjlAG3ZA3o4cBHVAkjzc2Z20","path":"window.location.pathname","placeholder":"留言仅限讨论，禁止广告等行为","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://fifc7wqu.api.lncldglobal.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <meta name="referrer" content="no-referrer" /> <footer id="footer" role="contentinfo"> <meta name="referrer" content="no-referrer" /> <div class="divider"> <div class="wall"></div> <img class="animals" src="/img/footer_animals_new.png" srcset="/img/loading.gif" lazyload alt="Footer Animals"> </div> <div class="container" data-index="450"> <p> <a href="https://chiamzhang.github.io" target="_blank">DogEgg</a> <i class="iconfont icon-love"></i> <a href="#" target="_blank">LittePig</a> </p> <p> Powered by  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-pen"></i> Theme  <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </p> </div> </footer> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/love.js"></script>
<script src="/js/funnyTitle.js"></script>
<script src="/js/backTop.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxuehua.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
